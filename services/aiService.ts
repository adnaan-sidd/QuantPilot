import { GoogleGenAI, Type } from "@google/genai";
import { StrategyConfig, Trade, ChatMessage, ChatResponse, AIReport } from "../types";

// Initialize Gemini Client Lazily
let aiClient: GoogleGenAI | null = null;

const getAiClient = () => {
    if (!aiClient && process.env.API_KEY) {
        aiClient = new GoogleGenAI({ apiKey: process.env.API_KEY });
    }
    return aiClient;
};

// Models
const REASONING_MODEL = "gemini-3-pro-preview";
const FAST_MODEL = "gemini-2.5-flash";

// --- MOCK FALLBACK GENERATORS (Used if API fails) ---

const getMockStrategyConfig = (description: string): StrategyConfig => {
  const isBtc = description.toLowerCase().includes('bitcoin') || description.toLowerCase().includes('btc');
  return {
    asset: isBtc ? "BTCUSD" : "EURUSD",
    timeframe: "H1",
    entryRules: [
      "RSI(14) crosses below 30 (Oversold)",
      "Price > EMA(200) (Trend Filter)"
    ],
    exitRules: [
      "RSI(14) crosses above 70",
      "Trailing Stop 50 pips"
    ],
    stopLoss: "50 pips",
    takeProfit: "100 pips",
    riskPerTrade: "1%"
  };
};

const getMockBotCode = (language: string, config: StrategyConfig): string => {
    return `// Mock code for ${language} based on ${config.asset}
// Strategy: ${JSON.stringify(config.entryRules)}
// Risk: ${config.riskPerTrade}

// Generated by AI Strategy Backtester
`;
}

// --------------------------------

export const continueStrategyChat = async (messages: ChatMessage[]): Promise<ChatResponse> => {
   const ai = getAiClient();
   // Use mock if no API key
   if (!ai) {
       const lastMsg = messages[messages.length - 1].content;
       const isStrategy = lastMsg.toLowerCase().includes('rsi') || lastMsg.toLowerCase().includes('buy');
       
       return {
           message: isStrategy 
            ? "I've drafted a strategy based on your description. You can adjust the settings or run a backtest."
            : "I can help you build a strategy. Try saying 'Buy EURUSD when RSI is below 30'.",
           config: isStrategy ? getMockStrategyConfig(lastMsg) : undefined,
           shouldExecute: lastMsg.toLowerCase().includes('run') || lastMsg.toLowerCase().includes('test')
       };
   }

   try {
    const history = messages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n');
    const prompt = `
        You are an expert algorithmic trading assistant.
        The user is describing a trading strategy. Help them refine it.
        
        Conversation History:
        ${history}
        
        1. Answer the user's latest message helpfully.
        2. If the user has provided enough information to form a strategy (asset, entry, exit), extract it into the 'config' field. Infer reasonable defaults for missing fields (e.g. EURUSD, H1, 1% risk).
        3. If the user explicitly asks to "run", "test", or "backtest" the strategy, OR if they accept a suggested strategy, set 'shouldExecute' to true.
        
        Return JSON.
    `;

    // Use Thinking Mode for understanding complex strategy intent
    const response = await ai.models.generateContent({
        model: REASONING_MODEL,
        contents: prompt,
        config: {
            thinkingConfig: { thinkingBudget: 32768 }, // Max thinking for deep reasoning
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    message: { type: Type.STRING },
                    shouldExecute: { type: Type.BOOLEAN },
                    config: {
                        type: Type.OBJECT,
                        properties: {
                             asset: { type: Type.STRING },
                             timeframe: { type: Type.STRING },
                             entryRules: { type: Type.ARRAY, items: { type: Type.STRING } },
                             exitRules: { type: Type.ARRAY, items: { type: Type.STRING } },
                             stopLoss: { type: Type.STRING },
                             takeProfit: { type: Type.STRING },
                             riskPerTrade: { type: Type.STRING }
                        },
                        required: ["asset", "timeframe", "entryRules", "exitRules", "stopLoss", "takeProfit", "riskPerTrade"]
                    }
                },
                required: ["message"]
            }
        }
    });

    if (response.text) {
        return JSON.parse(response.text) as ChatResponse;
    }
    throw new Error("Empty response");
   } catch (err) {
       console.error("AI Chat Error", err);
       return { message: "I'm having trouble connecting to the strategy engine. Please try again." };
   }
};

export const parseStrategyFromText = async (description: string): Promise<StrategyConfig> => {
  const ai = getAiClient();
  if (!ai) return getMockStrategyConfig(description);

  try {
    const prompt = `
        You are StrategyParserAI, an expert quantitative analyst and trading systems architect.
        Your task is to take any free-form natural language trading strategy and convert it into a STRICT, FORMAL, MACHINE-READABLE JSON configuration.

        The user will describe a trading strategy in plain English. You must extract ALL logical components.

        Strategy Description: "${description}"

        -----------------------------------------------------
        ✔ INTERPRETATION RULES:
        - Infer missing details intelligently using common trading standards.
        - If timeframe or date range is missing → default to M15.
        - Identify indicators with parameters, e.g. "RSI < 30" → {"indicator": "RSI", "period": 14, "condition": "<", "value": 30}
        - Recognize patterns: Bullish Engulfing, Break of structure, Support/Resistance breakout.
        - Detect Buy rules, Sell rules, SL, TP, Risk.
        
        -----------------------------------------------------
        IMPORTANT:
        - NEVER hallucinate data. Only infer logical defaults.
        - NEVER output explanation or text. ONLY JSON.
    `;

    const response = await ai.models.generateContent({
      model: REASONING_MODEL, 
      contents: prompt,
      config: {
        thinkingConfig: { thinkingBudget: 32768 },
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            asset: { type: Type.STRING, description: "The trading symbol e.g., EURUSD, BTCUSD" },
            timeframe: { type: Type.STRING, description: "Timeframe e.g., M15, H1, D1" },
            entryRules: { 
              type: Type.ARRAY, 
              items: { type: Type.STRING },
              description: "List of conditions to enter a trade" 
            },
            exitRules: { 
              type: Type.ARRAY, 
              items: { type: Type.STRING },
              description: "List of conditions to exit a trade" 
            },
            stopLoss: { type: Type.STRING, description: "Stop loss rule" },
            takeProfit: { type: Type.STRING, description: "Take profit rule" },
            riskPerTrade: { type: Type.STRING, description: "Risk per trade e.g. 1%" }
          },
          required: ["asset", "timeframe", "entryRules", "exitRules", "stopLoss", "takeProfit", "riskPerTrade"]
        }
      }
    });

    if (response.text) {
      return JSON.parse(response.text) as StrategyConfig;
    }
    throw new Error("Empty response from AI");

  } catch (err) {
    console.warn("Gemini API Error (Falling back to mock):", err);
    return getMockStrategyConfig(description);
  }
};

export const generateBotCode = async (config: StrategyConfig, language: 'python' | 'pinescript' | 'mt5'): Promise<string> => {
  const ai = getAiClient();
  if (!ai) return getMockBotCode(language, config);

  try {
    const langName = language === 'mt5' ? 'MQL5 (MetaTrader 5)' : language === 'pinescript' ? 'Pine Script v5' : 'Python (using Backtrader)';
    
    // Code generation is structural, Flash is usually sufficient and faster.
    const response = await ai.models.generateContent({
      model: FAST_MODEL,
      contents: `
        You are an expert trading bot developer.
        Generate production-ready, error-free trading bot code for the following strategy configuration.
        
        Language: ${langName}
        
        Configuration:
        ${JSON.stringify(config, null, 2)}
        
        Include comments explaining the logic.
        Ensure standard error handling and proper syntax.
        Return ONLY the code, no markdown formatting.
      `
    });

    return response.text || getMockBotCode(language, config);

  } catch (err) {
    console.warn("Gemini API Error (Falling back to mock):", err);
    return getMockBotCode(language, config);
  }
};

export const generateReportNarrative = async (stats: any, trades: Trade[], config: StrategyConfig): Promise<AIReport> => {
  const ai = getAiClient();
  if (!ai) {
      return {
        narrative: "This report was generated in offline mode...",
        suggestions: "1. Optimize the RSI period.\n2. Add a volatility filter.",
        grade: "C",
        conciseSummary: "The strategy shows average performance with moderate drawdown."
      };
  }

  try {
    const sortedTrades = [...trades].sort((a, b) => b.pnl - a.pnl);
    const topWins = sortedTrades.slice(0, 3);
    const topLosses = sortedTrades.slice(-3);
    const representativeTrades = { topWins, topLosses };

    const response = await ai.models.generateContent({
      model: REASONING_MODEL,
      contents: `
        Analyze the backtest results for this strategy.
        
        Strategy: ${JSON.stringify(config)}
        Stats: ${JSON.stringify(stats)}
        Representative Trades: ${JSON.stringify(representativeTrades)}
        
        1. Write a "Market Context Analysis" (narrative) explaining where the strategy succeeded. 
           CRITICAL: Explicitly identify the specific market conditions (e.g., "Trending Markets", "Range-bound Volatility", "High Momentum") where the strategy performed well versus where it failed (e.g. "Choppy markets", "Reversal points").
        2. Provide 3 specific "Optimization Suggestions".
        3. Assign a "Grade" (A, B, C, D, F) based on Profit Factor, Drawdown, and consistency. A is excellent (PF > 2.0, Low DD), F is losing money.
        4. Provide a "Concise Summary" (1-2 sentences) of the overall performance and grade justification.
        
        Return JSON.
      `,
      config: {
        thinkingConfig: { thinkingBudget: 32768 },
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            narrative: { type: Type.STRING },
            suggestions: { type: Type.STRING },
            grade: { type: Type.STRING, enum: ["A", "B", "C", "D", "F"] },
            conciseSummary: { type: Type.STRING }
          },
          required: ["narrative", "suggestions", "grade", "conciseSummary"]
        }
      }
    });

    if (response.text) {
      return JSON.parse(response.text) as AIReport;
    }
    throw new Error("Empty response from AI");

  } catch (err) {
    console.warn("Gemini API Error (Falling back to mock):", err);
    return {
        narrative: "Error generating report.",
        suggestions: "N/A",
        grade: "C",
        conciseSummary: "Analysis unavailable due to connection error."
    };
  }
};

// --- SIMULATED ASYNC SUGGESTIONS ---
export const fetchDetailedSuggestions = async (partialInput: string): Promise<string[]> => {
    // In a real app, this would hit an API.
    // We simulate a delay and return context-aware suggestions.
    await new Promise(r => setTimeout(r, 400)); // Network delay simulation

    const lowerInput = partialInput.toLowerCase();
    
    // Dictionary of patterns
    const patterns = [
        { key: 'rsi', suggestions: ['RSI Divergence', 'RSI Overbought/Oversold', 'RSI Trend Confirmation'] },
        { key: 'sma', suggestions: ['SMA Golden Cross', 'SMA Death Cross', 'Price > 200 SMA'] },
        { key: 'ema', suggestions: ['EMA Crossover', 'Price > 20 EMA Pullback'] },
        { key: 'macd', suggestions: ['MACD Zero Line Cross', 'MACD Signal Cross', 'MACD Divergence'] },
        { key: 'bollinger', suggestions: ['Bollinger Band Squeeze', 'Bollinger Breakout', 'Bollinger Mean Reversion'] },
        { key: 'support', suggestions: ['Support Bounce', 'Support Breakout'] },
        { key: 'resistance', suggestions: ['Resistance Rejection', 'Resistance Breakout'] }
    ];

    const match = patterns.find(p => lowerInput.includes(p.key));
    if (match) {
        return match.suggestions;
    }
    
    return [];
};